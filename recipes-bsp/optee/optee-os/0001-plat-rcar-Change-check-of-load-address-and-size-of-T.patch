From f6c4c8962b4c9283a1be10bc7f0d8a5fc889a2de Mon Sep 17 00:00:00 2001
From: Toshiyuki Ogasahara <toshiyuki.ogasahara.bo@hitachi.com>
Date: Fri, 7 Feb 2020 11:05:06 +0900
Subject: [PATCH 1/2] plat-rcar: Change check of load address and size of TA
 for Dynamic TA authentication

The following modifications have been implemented to prevent unauthorized
authentication of Dynamic TA authentication.
- Added the check of memory load address
- Change the check of TA size and certificate size

Signed-off-by: Toshiyuki Ogasahara <toshiyuki.ogasahara.bo@hitachi.com>
Signed-off-by: Yoshifumi Hosoya <yoshifumi.hosoya.wj@renesas.com>
---
 core/arch/arm/plat-rcar/rcar_common.h  |   3 +-
 core/arch/arm/plat-rcar/rcar_ta_auth.c | 134 +++++++++++++++++++++++----------
 core/arch/arm/plat-rcar/rcar_ta_auth.h |   4 +-
 3 files changed, 99 insertions(+), 42 deletions(-)

diff --git a/core/arch/arm/plat-rcar/rcar_common.h b/core/arch/arm/plat-rcar/rcar_common.h
index f57a3db..a98e2ec 100644
--- a/core/arch/arm/plat-rcar/rcar_common.h
+++ b/core/arch/arm/plat-rcar/rcar_common.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: BSD-2-Clause */
 /*
- * Copyright (c) 2015-2019, Renesas Electronics Corporation
+ * Copyright (c) 2015-2020, Renesas Electronics Corporation
  */
 
 #ifndef RCAR_COMMON_H
@@ -58,7 +58,6 @@
 /* Product Register */
 #define PRR			(0xFFF00044U)
 #define PRR_PRODUCT_MASK	(0x0000FF00U)
-#define PRR_PRODUCT_UNKNOWN	(0x000000FFU)
 #define PRR_PRODUCT_API_TABLE	(0x00010000U)
 #define PRR_PRODUCT_H3		(0x00004F00U)	/* R-Car H3 */
 #define PRR_PRODUCT_M3		(0x00005200U)	/* R-Car M3 */
diff --git a/core/arch/arm/plat-rcar/rcar_ta_auth.c b/core/arch/arm/plat-rcar/rcar_ta_auth.c
index d390f60..c5b3340 100644
--- a/core/arch/arm/plat-rcar/rcar_ta_auth.c
+++ b/core/arch/arm/plat-rcar/rcar_ta_auth.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: BSD-2-Clause
 /*
- * Copyright (c) 2015-2017, Renesas Electronics Corporation
+ * Copyright (c) 2015-2020, Renesas Electronics Corporation
  */
 
 #include <string.h>
@@ -33,8 +33,6 @@
 #define CERT_IDX_VER			(1)
 #define CERT_IDX_SIZE			(2)
 #define CERT_IDX_FLAG			(3)
-#define KEY_CERT_DEFAULT_SIZE		(0x24cU)
-#define CONTENT_CERT_DEFAULT_SIZE	(0x268U)
 #define RST_MODEMR			(RST_BASE + 0x0060U)
 #define MFIS_SOFTMDR			(MFIS_BASE + 0x0600U)
 #define LCS_CM				(0x0U)
@@ -44,22 +42,25 @@
 #define LCS_FA				(0x7U)
 #define SECURE_BOOT_MODE		(0U)
 #define NORMAL_BOOT_MODE		(1U)
+#define CERT_IDX_MEM_LOAD_ADDR	(84U)
+#define TA_OBJ_SIZE				((TA_KEY_CERT_ADDR - \
+					TA_VERIFICATION_BASE) / CERT_BLOCK_SIZE)
 
 /* Declaration of internal function */
 static uint32_t get_key_cert_size(const uint32_t *cert_header);
 static uint32_t get_content_cert_size(const uint32_t *cert_header);
-static uint32_t get_object_size(const void *content_cert);
+static uint32_t get_object_size(const uint32_t *content_cert);
 static uint32_t get_auth_mode(void);
 static uint32_t call_maskrom_api(void);
+static uint64_t check_object_addr(const uint32_t *cert_header);
 
 static uint32_t get_key_cert_size(const uint32_t *cert_header)
 {
-	uint32_t cert_size;
+	uint32_t cert_size = 0U;
 	uint32_t hdr_tmp;
 	uint32_t sig_size;
 
-	cert_size = ((cert_header[CERT_IDX_SIZE] & CERT_OFS_BIT_SIZE) *
-		CERT_BLOCK_SIZE);
+
 
 	hdr_tmp = (cert_header[CERT_IDX_FLAG] & 0x00600000U) >> 21U;
 	sig_size = CERT_SIGNATURE_SIZE;
@@ -72,33 +73,77 @@ static uint32_t get_key_cert_size(const uint32_t *cert_header)
 		/* no operation */
 	}
 
-	cert_size += sig_size;
+	if (hdr_tmp < 3U) {
+		cert_size = ((cert_header[CERT_IDX_SIZE] & CERT_OFS_BIT_SIZE) *
+			CERT_BLOCK_SIZE);
+		cert_size += sig_size;
+	}
 
 	return cert_size;
 }
 
+static uint64_t check_object_addr(const uint32_t *cert_header)
+{
+	uint32_t cert_idx_mem_load_addr;
+	uint32_t hdr_tmp;
+	uint32_t sig_size;
+	uint64_t obj_addr = 0U;
+
+	hdr_tmp = (cert_header[CERT_IDX_FLAG] & 0x00600000U) >> 21U;
+	sig_size = CERT_SIGNATURE_SIZE;
+
+	if (hdr_tmp == 1U) {
+		sig_size += CERT_SIGNATURE_SIZE / 2U;
+	} else if (hdr_tmp == 2U) {
+		sig_size += CERT_SIGNATURE_SIZE;
+	} else {
+		/* no operation */
+	}
+
+	if (hdr_tmp < 3U) {
+		cert_idx_mem_load_addr = (CERT_IDX_MEM_LOAD_ADDR + sig_size)
+					/ CERT_BLOCK_SIZE;
+
+		obj_addr = (uint64_t)(cert_header[cert_idx_mem_load_addr + 1U]);
+		obj_addr = obj_addr << 32U;
+		obj_addr += (uint64_t)(cert_header[cert_idx_mem_load_addr]);
+	}
+
+	return obj_addr;
+}
+
 static uint32_t get_content_cert_size(const uint32_t *cert_header)
 {
 	uint32_t cert_size;
 
-	cert_size = get_key_cert_size(cert_header) + CERT_ADD_DATA_SIZE;
+	cert_size = get_key_cert_size(cert_header);
+	if (cert_size != 0U) {
+		cert_size += CERT_ADD_DATA_SIZE;
+	}
 
 	return cert_size;
 }
 
-static uint32_t get_object_size(const void *content_cert)
+static uint32_t get_object_size(const uint32_t *content_cert)
 {
-	uint32_t obj_size;
+	uint32_t obj_size = 0U;
 	const uint32_t *cert_header;
 	uint32_t offset;
-	const void *obj_len;
+	const uint32_t *obj_len;
 
-	cert_header = (const uint32_t *)content_cert;
-	offset = get_key_cert_size(cert_header) + CERT_STORE_ADDR_SIZE;
-	obj_len = (const uint8_t *)content_cert + offset;
-	obj_size = *(const uint32_t *)obj_len;
-	obj_size *= CERT_BLOCK_SIZE;
+	cert_header = content_cert;
+	offset = get_key_cert_size(cert_header);
+	if (offset != 0U) {
+		offset += CERT_STORE_ADDR_SIZE;
+		obj_len = content_cert + (offset / 4U);
+		obj_size = *obj_len;
 
+		if (obj_size > TA_OBJ_SIZE) {
+			obj_size = 0U;
+		} else {
+			obj_size *= CERT_BLOCK_SIZE;
+		}
+	}
 	return obj_size;
 }
 
@@ -156,36 +201,54 @@ static uint32_t call_maskrom_api(void)
 	return ret;
 }
 
-TEE_Result rcar_auth_ta_certificate(const void *key_cert,
+TEE_Result rcar_auth_ta_certificate(const struct shdr *key_cert,
 				struct shdr **secmem_ta)
 {
-	TEE_Result res = TEE_ERROR_SECURITY;
+	TEE_Result res = TEE_SUCCESS;
 	uint32_t ret;
 	uint32_t key_cert_size;
-	uint32_t content_cert_size;
-	uint32_t object_size;
+	uint32_t content_cert_size = 0U;
+	uint32_t object_size = 0U;
 	uint32_t auth_mode;
-	const void *content_cert;
+	const uint32_t *content_cert;
 	struct shdr *fixed_ta = (struct shdr *)TA_VERIFICATION_BASE;
 	uint8_t *fixed_base = (uint8_t *)TA_VERIFICATION_BASE;
 	uint8_t *fixed_key_cert = (uint8_t *)TA_KEY_CERT_ADDR;
 	uint8_t *fixed_content_cert = (uint8_t *)TA_CONTENT_CERT_ADDR;
+	uint64_t object_addr;
 
 	key_cert_size = get_key_cert_size((const uint32_t *)key_cert);
-	if (key_cert_size > TA_KEY_CERT_AREA_SIZE) {
-		key_cert_size = KEY_CERT_DEFAULT_SIZE;
+	if ((key_cert_size == 0U) || (key_cert_size > TA_KEY_CERT_AREA_SIZE)) {
+		res = TEE_ERROR_SECURITY;
 	}
-	content_cert = (const uint8_t *)key_cert + key_cert_size;
-	content_cert_size = get_content_cert_size(
-				(const uint32_t *)content_cert);
-	if (content_cert_size > TA_CONTENT_CERT_AREA_SIZE) {
-		content_cert_size = CONTENT_CERT_DEFAULT_SIZE;
+
+	if (res == TEE_SUCCESS) {
+		content_cert = (const uint32_t *)key_cert + (key_cert_size / 4U);
+		content_cert_size = get_content_cert_size(content_cert);
+		if ((content_cert_size == 0U) ||
+			(content_cert_size > TA_CONTENT_CERT_AREA_SIZE)) {
+			res = TEE_ERROR_SECURITY;
+		}
+	}
+
+	if (res == TEE_SUCCESS) {
+		object_size = get_object_size(content_cert);
+		if (object_size == 0U) {
+			res = TEE_ERROR_SECURITY;
+		}
 	}
-	object_size = get_object_size(content_cert);
 
 	DMSG("TA size: key_cert=0x%x content_cert=0x%x shdr+bin=0x%x",
 		key_cert_size, content_cert_size, object_size);
 
+	/* check the address of loading TA is the top of verification area */
+	if (res == TEE_SUCCESS) {
+		object_addr = check_object_addr(content_cert);
+		if (object_addr != TA_VERIFICATION_BASE) {
+			res = TEE_ERROR_SECURITY;
+		}
+	}
+
 	/*
 	 *   Fixed memory map          | TotalSize=TA_VERIFICATION_SIZE
 	 * ---------------------------------------------------------------
@@ -199,11 +262,7 @@ TEE_Result rcar_auth_ta_certificate(const void *key_cert,
 	 * | Non-cache Stack area      | [3]=TA_NONCACHE_STACK_AREA_SIZE |
 	 * ---------------------------------------------------------------
 	 */
-	if ((product_type & PRR_PRODUCT_UNKNOWN) != 0U) {
-		EMSG("Unknown product error. product=0x%x r=0x%x",
-			product_type & PRR_PRODUCT_MASK, res);
-	} else if ((fixed_base + object_size) <= fixed_key_cert) {
-
+	if (res == TEE_SUCCESS) {
 		/* copy to fixed memory */
 		(void)memcpy(fixed_base,
 			(const uint8_t *)content_cert + content_cert_size,
@@ -225,18 +284,17 @@ TEE_Result rcar_auth_ta_certificate(const void *key_cert,
 			if (ret == 0U) {
 				DMSG("[%s] Secure boot success!", product_name);
 				*secmem_ta = fixed_ta;
-				res = TEE_SUCCESS;
 			} else {
 				EMSG("[%s] Secure boot error. 0x%x",
 					product_name, ret);
+				res = TEE_ERROR_SECURITY;
 			}
 		} else {
 			DMSG("[%s] Normal boot", product_name);
 			*secmem_ta = fixed_ta;
-			res = TEE_SUCCESS;
 		}
 	} else {
-		EMSG("Overflow error. r=0x%x", res);
+		EMSG("Security error. r=0x%x", res);
 	}
 
 	return res;
diff --git a/core/arch/arm/plat-rcar/rcar_ta_auth.h b/core/arch/arm/plat-rcar/rcar_ta_auth.h
index 236a791..6874c42 100644
--- a/core/arch/arm/plat-rcar/rcar_ta_auth.h
+++ b/core/arch/arm/plat-rcar/rcar_ta_auth.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: BSD-2-Clause */
 /*
- * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * Copyright (c) 2015-2020 Renesas Electronics Corporation
  */
 
 #ifndef RCAR_TA_AUTH_H
@@ -10,7 +10,7 @@
 #include <signed_hdr.h>
 #include "tee_api_types.h"
 
-TEE_Result rcar_auth_ta_certificate(const void *key_cert,
+TEE_Result rcar_auth_ta_certificate(const struct shdr *key_cert,
 				struct shdr **secmem_ta);
 
 #endif /* RCAR_TA_AUTH_H */
-- 
1.9.1

